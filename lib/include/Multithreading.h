#pragma once

template <typename T>
struct cpu_atomic
{
public:
	void operator=(const T& v) { val = v; }
	T AddOne() { return val.fetch_add(1, std::memory_order_relaxed); }

private:
	std::atomic<T> val;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct cpu_tile
{
	int left;
	int top;
	int right;
	int bottom;
	int index;
	int row;
	int col;

	// Entity
	int statsDrawnTriangleCount;

	// Particle
	std::vector<int> particleLocalCounts;
	int particleCount;
	int particleOffset;
	int particleOffsetTemp;

	void Reset();
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class cpu_thread_job : public cpu_thread
{
public:
	~cpu_thread_job();
	void Create(int count);
	void Stop();
	void PostStartEvent(cpu_job* pJob);
	void PostEndEvent();
	void WaitStartEvent();
	void WaitEndEvent();
	bool IsWorking() { return m_isWorking; }
	void OnCallback() override;

protected:
	int m_count;
	HANDLE m_hEventStart;
	HANDLE m_hEventEnd;
	cpu_job* m_pJob;
	bool m_isWorking;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class cpu_job
{
public:
	void Create(cpu_thread_job* pThread);

	cpu_thread_job* GetThread() { return m_pThread; }

	virtual void OnJob(int iTile) = 0;

protected:
	cpu_thread_job* m_pThread;
};

class cpu_job_entity : public cpu_job
{
public:
	void OnJob(int iTile) override;
};

class cpu_job_particle_physics : public cpu_job
{
public:
	void OnJob(int iTile) override;
};

class cpu_job_particle_space : public cpu_job
{
public:
	void OnJob(int iTile) override;
};

class cpu_job_particle_render : public cpu_job
{
public:
	void OnJob(int iTile) override;
};
