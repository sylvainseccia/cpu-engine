#pragma once

namespace cpu
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename E, typename A>
void Run(HINSTANCE hInstance, int renderWidth, int renderHeight, bool fullscreen = false, bool amigaStyle = false)
{
#ifdef _DEBUG
	_CrtMemState memStateInit;
	_CrtMemCheckpoint(&memStateInit);
#endif

	E* pEngine = new E;
	if ( pEngine->Initialize(hInstance, renderWidth, renderHeight, fullscreen, amigaStyle) )
	{
		A* pApp = new A;
		pEngine->Run();
		delete pApp;
	}
	delete pEngine;

#ifdef _DEBUG
	_CrtMemState memState, memStateDiff;
	_CrtMemCheckpoint(&memState);
	if ( _CrtMemDifference(&memStateDiff, &memStateInit, &memState) )
		MessageBoxA(nullptr, "Memory leaks", "ALERT", 0);
	_CrtDumpMemoryLeaks();
#endif
}

template <typename S>
int& GetStateID() { static int id = -1; return id; }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ui32 SwapRB(ui32 color);

ui32 ToRGB(XMFLOAT3& color);
ui32 ToRGB(float r, float g, float b);
ui32 ToRGB(int r, int g, int b);

ui32 ToBGR(XMFLOAT3& color);
ui32 ToBGR(float r, float g, float b);

XMFLOAT3 ToColor(int r, int g, int b);
XMFLOAT3 ToColorFromRGB(ui32 rgb);
XMFLOAT3 ToColorFromBGR(ui32 bgr);

ui32 LerpColor(ui32 c0, ui32 c1, float t);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float Clamp(float v);
float Clamp(float v, float min, float max);
int Clamp(int v, int min, int max);
int FloorToInt(float v);
int CeilToInt(float v);
int RoundToInt(float v);
ui32 WangHash(ui32 x);
float Rand01(ui32& seed);
float RandSigned(ui32& seed);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static inline XMFLOAT3 Sub3(const XMFLOAT3& a, const XMFLOAT3& b) { return {a.x-b.x, a.y-b.y, a.z-b.z}; }
static inline XMFLOAT3 Add3(const XMFLOAT3& a, const XMFLOAT3& b) { return {a.x+b.x, a.y+b.y, a.z+b.z}; }
static inline XMFLOAT3 Mul3(const XMFLOAT3& a, float s) { return {a.x*s, a.y*s, a.z*s}; }
static inline float Dot3(const XMFLOAT3& a, const XMFLOAT3& b) { return a.x*b.x + a.y*b.y + a.z*b.z; }
static inline XMFLOAT3 Cross3(const XMFLOAT3& a, const XMFLOAT3& b) { return { a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x }; }

bool SphereSphere(XMFLOAT3& c1, float r1, XMFLOAT3& c2, float r2);
bool RaySphere(cpu_ray& ray, XMFLOAT3& center, float radius, XMFLOAT3& outHit, float* pOutT = nullptr);
bool RayAabb(cpu_ray& ray, cpu_aabb& box, XMFLOAT3* pOutHit = nullptr, float* outT = nullptr);
bool RayAabb(cpu_ray& ray, cpu_aabb& box, float& outTEnter, float& outTExit);
bool RayTriangle(cpu_ray& ray, cpu_triangle& tri, XMFLOAT3& outHit, float* outT = nullptr, XMFLOAT3* outBary = nullptr, bool cullBackFace = false);
bool AabbAabb(cpu_aabb& a, cpu_aabb& b);
bool AabbAabbInclusive(cpu_aabb& a, cpu_aabb& b);

XMFLOAT3 SphericalPoint(float r, float theta, float phi);
RECT ComputeAspectFitRect(int contentW, int contentH, int winW, int winH);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

byte* LoadFile(const char* path, int& size);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}