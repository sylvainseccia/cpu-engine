#include "stdafx.h"

ui32 ToRGB(XMFLOAT3& color)
{
	int r = Clamp((int)(color.x*255.0f), 0, 255);
	int g = Clamp((int)(color.y*255.0f), 0, 255);
	int b = Clamp((int)(color.z*255.0f), 0, 255);
	return RGB(r, g, b);
}

ui32 ToBGR(XMFLOAT3& color)
{
	int r = Clamp((int)(color.z*255.0f), 0, 255);
	int g = Clamp((int)(color.y*255.0f), 0, 255);
	int b = Clamp((int)(color.x*255.0f), 0, 255);
	return RGB(r, g, b);
}

XMFLOAT3 ToColor(int r, int g, int b)
{
	XMFLOAT3 color;
	color.x = Clamp(r, 0, 255)/255.0f;
	color.y = Clamp(g, 0, 255)/255.0f;
	color.z = Clamp(b, 0, 255)/255.0f;
	return color;
}

ui32 LerpBGR(ui32 c0, ui32 c1, float t)
{
	int b0 = (int)( c0        & 255);
	int g0 = (int)((c0 >>  8) & 255);
	int r0 = (int)((c0 >> 16) & 255);
	int b1 = (int)( c1        & 255);
	int g1 = (int)((c1 >>  8) & 255);
	int r1 = (int)((c1 >> 16) & 255);
	float it = 1.0f - t;
	int b = (int)(b0 * it + b1 * t);
	int g = (int)(g0 * it + g1 * t);
	int r = (int)(r0 * it + r1 * t);
	return (ui32)b | ((ui32)g << 8) | ((ui32)r << 16);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float Clamp(float v)
{
	if ( v<0.0f )
		return 0.0f;
	if ( v>1.0f )
		return 1.0f;
	return v;
}

float Clamp(float v, float min, float max)
{
	if ( v<min )
		return min;
	if ( v>max )
		return max;
	return v;
}

int Clamp(int v, int min, int max)
{
	if ( v<min )
		return min;
	if ( v>max )
		return max;
	return v;
}

int FloorToInt(float v)
{
	int i = (int)v;
	return (float)i>v ? i-1 : i;
}

int CeilToInt(float v)
{
	int i = (int)v;
	return (float)i<v ? i+1 : i;
}

int RoundToInt(float v)
{
	int i = (int)v;
	return v>=0.0f ? ((float)i+0.5f<=v ? i+1 : i) : ((float)i-0.5f>=v ? i-1 : i);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

XMFLOAT3 SphericalPoint(float r, float theta, float phi)
{
	float st = sinf(theta);
	float ct = cosf(theta);
	float sp = sinf(phi);
	float cp = cosf(phi);
	return XMFLOAT3(r * st * cp, r * ct, r * st * sp);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

byte* LoadFile(const char* path, int& size)
{
	byte* data = nullptr;
	FILE* file;
	if ( fopen_s(&file, path, "rb") )
		return data;
	fseek(file, 0, SEEK_END);
	size = ftell(file);
	fseek(file, 0, SEEK_SET);
	if ( size>0 )
	{
		data = new byte[size];
		fread(data, 1, size, file);
	}
	fclose(file);
	return data;
}
