#pragma once

struct cpu_transform
{
	// Position
	XMFLOAT3 pos;

	// Scaling
	XMFLOAT3 sca;

	// Rotation
	XMFLOAT3 dir;
	XMFLOAT3 right;
	XMFLOAT3 up;
	XMFLOAT4 quat;
	XMFLOAT4X4 rot;

	// World
	XMFLOAT4X4 world;
	
	cpu_transform();
	void Identity();
	void Update();
	void SetScaling(float scale);
	void SetPosition(float x, float y, float z);
	void Move(float dist);
	void OrbitAroundAxis(XMFLOAT3& center, XMFLOAT3& axis, float radius, float angle);
	void ResetRotation();
	void SetRotation(cpu_transform& transform);
	void SetYPR(float yaw, float pitch = 0.0f, float roll = 0.0f);
	void AddYPR(float yaw, float pitch = 0.0f, float roll = 0.0f);
	void LookAt(float x, float y, float z);
	void LookTo(float ndx, float ndy, float ndz);
	void LookTo(XMFLOAT3& ndir);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct cpu_entity
{
	int index;
	int sortedIndex;
	bool dead;
	cpu_mesh* pMesh;
	cpu_transform transform;
	XMFLOAT3 view;
	cpu_material* pMaterial;
	float lifetime;
	ui32 tile;
	float radius;
	cpu_aabb aabb;
	cpu_obb obb;
	cpu_rectangle box;
	bool clipped;
	byte depth;
	bool visible;

	cpu_entity();
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct cpu_frustum
{
	XMFLOAT4 planes[6]; // left, right, bottom, top, near, far

	cpu_frustum();
	void FromViewProj(const XMFLOAT4X4& viewProj);
	bool Intersect(const XMFLOAT3& center, float radius);
	XMVECTOR XM_CALLCONV NormalizePlane(FXMVECTOR p);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct cpu_camera
{
	float fov;
	float near;
	float far;
	XMFLOAT4X4 matView;
	XMFLOAT4X4 matProj;
	XMFLOAT4X4 matViewProj;
	cpu_transform transform;
	cpu_frustum frustum;

	cpu_camera();
	void UpdateProjection(float aspectRatio);
	void Update();
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<typename T>
struct cpu_manager
{
	std::vector<T*> list;
	std::vector<T*> sortedList;
	int count;
	std::vector<T*> bornList;
	int bornCount;
	std::vector<T*> deadList;
	int deadCount;

	cpu_manager()
	{
		Clear();
	}
	void Clear()
	{
		list.clear();
		sortedList.clear();
		count = 0;
		bornList.clear();
		bornCount = 0;
		deadList.clear();
		deadCount = 0;
	}
	T* operator[](int index) { return list[index]; }
	T* Create()
	{
		T* p = new T;
		if ( bornCount<bornList.size() )
			bornList[bornCount] = p;
		else
			bornList.push_back(p);
		bornCount++;
		return p;
	}
	void Add(T* p)
	{
		if ( bornCount<bornList.size() )
			bornList[bornCount] = p;
		else
			bornList.push_back(p);
		bornCount++;
	}
	void Release(T* p)
	{
		if ( p==nullptr || p->dead )
			return;
		p->dead = true;
		if ( deadCount<deadList.size() )
			deadList[deadCount] = p;
		else
			deadList.push_back(p);
		deadCount++;
	}
	void Purge()
	{
		// Born
		for ( int i=0 ; i<bornCount ; i++ )
		{
			T* p = bornList[i];
			if ( p->dead )
				continue;
			p->index = count;
			p->sortedIndex = p->index;
			if ( p->index<list.size() )
				list[p->index] = p;
			else
				list.push_back(p);
			if ( p->sortedIndex<sortedList.size() )
				sortedList[p->sortedIndex] = p;
			else
				sortedList.push_back(p);
			count++;
		}
		bornCount = 0;

		// Dead
		for ( int i=0 ; i<deadCount ; i++ )
		{
			T* p = deadList[i];
			if ( p->index==-1 )
			{
				delete deadList[i];
				deadList[i] = nullptr;
				continue;
			}
			if ( p->index<count-1 )
			{
				list[p->index] = list[count-1];
				list[p->index]->index = p->index;
			}
			if ( p->sortedIndex<count-1 )
			{
				sortedList[p->sortedIndex] = sortedList[count-1];
				sortedList[p->sortedIndex]->sortedIndex = p->sortedIndex;
			}
			delete deadList[i];
			deadList[i] = nullptr;
			count--;
		}
		deadCount = 0;
	}
};
