#include "pch.h"

float cpu_texture::lut[256];

cpu_texture::cpu_texture()
{
	bgra = nullptr;
	Close();
}

cpu_texture::~cpu_texture()
{
	Close();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cpu_texture::Load(const char* path)
{
	Close();

	int filesize;
	byte* data = cpu::LoadFile(path, filesize);
	if ( data==nullptr )
		return false;

	int w, h;
	byte* buf = cpu_png32::Load(data, filesize, &w, &h);
	delete [] data;
	if ( buf==nullptr )
		return false;

	bgra = buf;
	width = w;
	height = h;
	count = width * height;
	size = count * 4;

	for ( int i=0 ; i<size ; i+=4 )
	{
		byte r = bgra[i];
		bgra[i] = bgra[i+2];
		bgra[i+2] = r;
	}
	cpu_img32::Premultiply(bgra, bgra, width, height);
	return true;
}

void cpu_texture::Close()
{
	CPU_DELPTRS(bgra);
	width = 0;
	height = 0;
	count = 0;
	size = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int cpu_texture::FastFloorToInt(float x)
{
	// Cast tronque vers 0 : on corrige pour x négatif
	const int i = (int)x;
	return (x < (float)i) ? (i - 1) : i;
}

int cpu_texture::WrapPow2(int i, int sizePow2)
{
	// sizePow2 doit être une puissance de 2
	return i & (sizePow2 - 1);
}

// Sample texture nearest, repeat, pow2, Y=0 en haut
void cpu_texture::Sample(XMFLOAT3& outColor, float x, float y)
{
	// Repeat UV : u,v peuvent être quelconques
	// Nearest sampling, pixélisé
	const int tx = WrapPow2(FastFloorToInt(x * (float)width), width);
	const int ty = WrapPow2(FastFloorToInt(y * (float)height), height);
	const int index = ty * width * 4 + tx*4;
	outColor.x = lut[bgra[index+2]];
	outColor.y = lut[bgra[index+1]];
	outColor.z = lut[bgra[index+0]];
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void cpu_texture::Init()
{
	for ( int i=0 ; i<256 ; ++i )
		lut[i] = float(i) * (1.0f / 255.0f);
}
