#include "stdafx.h"

App::App()
{
	s_pApp = this;
	m_pShip = nullptr;
}

App::~App()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void App::SpawnMissile()
{
	cpu_entity* pMissile = CreateEntity();
	pMissile->pMesh = &m_meshMissile;
	pMissile->transform.SetScaling(0.2f);
	pMissile->transform.pos = m_pShip->GetEntity()->transform.pos;
	pMissile->transform.SetRotation(m_pShip->GetEntity()->transform);
	pMissile->transform.Move(1.5f);
	m_missiles.push_back(pMissile);
}

void App::SpawnMissileWithMouse()
{
	XMFLOAT2 pt;
	GetCursor(pt);
	cpu_ray ray = GetCameraRay(pt);
	cpu_entity* pMissile = CreateEntity();
	pMissile->pMesh = &m_meshMissile;
	pMissile->transform.SetScaling(0.2f);
	pMissile->transform.pos = ray.pos;
	pMissile->transform.LookTo(ray.dir);
	pMissile->transform.Move(1.5f);
	pMissile->pMaterial = &m_materialMissile;
	m_missiles.push_back(pMissile);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void App::OnStart()
{
	// YOUR CODE HERE

	// Resources
	m_font.Create(18);
	m_texture.Load("bird_amiga.png");
	m_meshShip.CreateSpaceship();
	m_meshMissile.CreateSphere(0.5f);
	m_meshSphere.CreateSphere(2.0f, 12, 12, ToColor(224, 224, 224));

	// UI
	m_pSprite = CreateSprite();
	m_pSprite->pTexture = &m_texture;
	m_pSprite->CenterAnchor();
	m_pSprite->x = 30;
	m_pSprite->y = 30;

	// Shader
	m_materialShip.color = ToColor(255, 128, 0);
	m_materialMissile.ps = MissileShader;
	m_materialRock.ps = RockShader;

	// 3D
	m_missileSpeed = 10.0f;
	m_camera.transform.pos.z = -5.0f;
	m_pBall = CreateEntity();
	m_pBall->pMesh = &m_meshSphere;
	m_pBall->transform.pos.x = 3.0f;
	m_pBall->transform.pos.y = 3.0f;
	m_pBall->transform.pos.z = 5.0f;
	m_pRock = CreateEntity();
	m_pRock->pMesh = &m_meshSphere;
	m_pRock->pMaterial = &m_materialRock;
	m_pRock->transform.SetScaling(0.1f);

	// Ship
	m_pShip = new Ship;
	m_pShip->Create(&m_meshShip, &m_materialShip);
	m_pShip->GetFSM()->ToState(ID(StateIdle));

	// Particle
	m_particleData.Create(1000000);
	m_particlePhysics.gy = -0.5f;
	m_pEmitter = CreateParticleEmitter();
	m_pEmitter->rate = 100000.0f;
	m_pEmitter->colorMin = ToColor(192, 192, 255);
	m_pEmitter->colorMax = ToColor(255, 192, 192);
}

void App::OnUpdate()
{
	// YOUR CODE HERE

	// Move sprite
	m_pSprite->y = 30 + RoundToInt(sinf(m_totalTime)*20.0f);

	// Turn ball
	m_pBall->transform.AddYPR(m_deltaTime);

	// Move rock
	m_pRock->transform.OrbitAroundAxis(m_pBall->transform.pos, UP, 3.0f, m_totalTime*2.0f);
	m_pEmitter->pos = m_pRock->transform.pos;
	m_pEmitter->dir = m_pRock->transform.dir;
	m_pEmitter->dir.x = -m_pEmitter->dir.x; 
	m_pEmitter->dir.y = -m_pEmitter->dir.y; 
	m_pEmitter->dir.z = -m_pEmitter->dir.z; 

	// Turn camera
	m_camera.transform.AddYPR(0.0f, 0.0f, m_deltaTime*0.1f);

	// Move ship
	if ( input.IsKey(VK_UP) )
	{
		m_camera.transform.Move(dtime*1.0f);
	}
	if ( input.IsKey(VK_DOWN) )
	{
		m_camera.transform.Move(-dtime*1.0f);
	}

	// Fire
	if ( input.IsKeyDown(VK_LBUTTON) || input.IsKey(VK_RBUTTON) )
		I(App)->SpawnMissileWithMouse();

	// Move missiles
	for ( auto it=m_missiles.begin() ; it!=m_missiles.end() ; )
	{
		cpu_entity* pMissile = *it;
		pMissile->transform.Move(m_deltaTime*m_missileSpeed);
		if ( pMissile->lifetime>10.0f )
		{
			it = m_missiles.erase(it);
			ReleaseEntity(pMissile);
		}
		else
			++it;
	}
}

void App::OnExit()
{
	// YOUR CODE HERE

	DELPTR(m_pShip);
	m_missiles.clear();
}

void App::OnPreRender()
{
	// YOUR CODE HERE
}

void App::OnPostRender()
{
	// YOUR CODE HERE

	// Debug
	std::string info = std::to_string(m_fps) + " fps, ";
	info += std::to_string(m_missiles.size()) + " missiles, ";
	info += std::to_string(m_statsClipEntityCount) + " clipped entities, ";
	info += std::to_string(m_statsDrawnTriangleCount) + " triangles, ";
	//info += std::to_string(m_statsDrawnTriangleCount) + "/" + std::to_string(GetTotalTriangleCount()) + " triangles, ";
	info += std::to_string(m_particleData.alive) + " particles, ";
	info += std::to_string(m_statsThreadCount) + " threads, ";
	info += std::to_string(m_statsTileCount) + " tiles\n";
	info += "(FIRE: space or left/right button)";
	DrawText(&m_font, info.c_str(), GetWidth()/2, 10, TEXT_CENTER);
}

void App::MissileShader(cpu_ps_io& io)
{
	// garder seulement le rouge du pixel éclairé
	io.color.x = io.p.color.x;
}

void App::RockShader(cpu_ps_io& io)
{
	float scale = ((sinf(ttime*3.0f)*0.5f)+0.5f) * 0.5f + 0.5f; 
	io.color.x = io.p.color.x * scale;
	io.color.y = io.p.color.y * scale;
	io.color.z = io.p.color.z;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Ship::Ship()
{
	m_pEntity = nullptr;
	m_pFSM = nullptr;
}

Ship::~Ship()
{
}

void Ship::Create(cpu_mesh* pMesh, cpu_material* pMaterial)
{
	m_pEntity = cpu.CreateEntity();
	m_pEntity->pMesh = pMesh;
	m_pEntity->pMaterial = pMaterial;
	m_pEntity->transform.pos.z = 5.0f;
	m_pEntity->transform.pos.y = -3.0f;

	m_pFSM = cpu.CreateFSM(this);
	m_pFSM->SetGlobal<StateGlobal>();
	m_pFSM->Add<StateIdle>();
	m_pFSM->Add<StateBlink>();
}

void Ship::Destroy()
{
	m_pFSM = cpu.ReleaseFSM(m_pFSM);
	m_pEntity = cpu.ReleaseEntity(m_pEntity);
}

void Ship::Update()
{
	// Turn ship
	m_pEntity->transform.AddYPR(dtime, dtime, dtime);

	// Move ship
	m_pEntity->transform.pos.z += dtime * 1.0f;

	// Fire
	if ( input.IsKey(VK_SPACE) )
		I(App)->SpawnMissile();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void StateGlobal::OnEnter(Ship& cur, int from)
{
}

void StateGlobal::OnExecute(Ship& cur)
{
	cur.Update();
}

void StateGlobal::OnExit(Ship& cur, int to)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void StateIdle::OnEnter(Ship& cur, int from)
{
}

void StateIdle::OnExecute(Ship& cur)
{
	// Blink every 3 seconds
	if ( cur.GetFSM()->totalTime>3.0f )
	{
		cur.GetFSM()->ToState(ID(StateBlink));
		return;
	}
}

void StateIdle::OnExit(Ship& cur, int to)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void StateBlink::OnEnter(Ship& cur, int from)
{
}

void StateBlink::OnExecute(Ship& cur)
{
	float v = fmod(cur.GetFSM()->totalTime, 0.2f);
	if ( v<0.1f )
	{
		cur.GetEntity()->visible = true;
	}
	else
	{
		cur.GetEntity()->visible = false;
	}

	if ( cur.GetFSM()->totalTime>1.0f )
	{
		cur.GetFSM()->ToState(ID(StateIdle));
		return;
	}
}

void StateBlink::OnExit(Ship& cur, int to)
{
}
