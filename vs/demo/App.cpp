#include "stdafx.h"

App::App()
{
	s_pApp = this;
	CPU_CALLBACK_START(OnStart);
	CPU_CALLBACK_UPDATE(OnUpdate);
	CPU_CALLBACK_EXIT(OnExit);
	CPU_CALLBACK_RENDER(OnRender);

	m_pShip = nullptr;
}

App::~App()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void App::SpawnMissile()
{
	cpu_entity* pMissile = CPU.CreateEntity();
	pMissile->pMesh = &m_meshMissile;
	pMissile->transform.SetScaling(0.2f);
	pMissile->transform.pos = m_pShip->GetEntity()->transform.pos;
	pMissile->transform.SetRotation(m_pShip->GetEntity()->transform);
	pMissile->transform.Move(1.5f);
	m_missiles.push_back(pMissile);
}

void App::SpawnMissileWithMouse()
{
	cpu_ray ray;
	CPU.GetCursorRay(ray);
	cpu_entity* pMissile = CPU.CreateEntity();
	pMissile->pMesh = &m_meshMissile;
	pMissile->transform.SetScaling(0.2f);
	pMissile->transform.pos = ray.pos;
	pMissile->transform.LookTo(ray.dir);
	pMissile->transform.Move(1.5f);
	pMissile->pMaterial = &m_materialMissile;
	m_missiles.push_back(pMissile);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void App::OnStart()
{
	// YOUR CODE HERE

	// Resources
	m_font.Create(0.04f);
	m_texture.Load("bird_amiga.png");
	m_meshShip.CreateSpaceship();
	m_meshMissile.CreateSphere(0.5f);
	m_meshSphere.CreateSphere(2.0f, 12, 12, cpu::ToColor(224, 224, 224));
	m_rts[0] = CPU.CreateRT();

	// UI
	m_pSprite = CPU.CreateSprite();
	m_pSprite->pTexture = &m_texture;
	m_pSprite->CenterAnchor();
	m_pSprite->x = 40;
	m_pSprite->y = 0;

	// Shader
	m_materialShip.color = cpu::ToColor(255, 128, 0);
	m_materialMissile.ps = MissileShader;
	m_materialRock.ps = RockShader;

	// 3D
	m_missileSpeed = 10.0f;
	m_pBall = CPU.CreateEntity();
	m_pBall->pMesh = &m_meshSphere;
	m_pBall->transform.pos.x = 3.0f;
	m_pBall->transform.pos.y = 3.0f;
	m_pBall->transform.pos.z = 5.0f;
	m_pRock = CPU.CreateEntity();
	m_pRock->pMesh = &m_meshSphere;
	m_pRock->pMaterial = &m_materialRock;
	m_pRock->transform.SetScaling(0.1f);

	// Ship
	m_pShip = new Ship;
	m_pShip->Create(&m_meshShip, &m_materialShip);
	m_pShip->GetFSM()->ToState(CPU_ID(StateIdle));

	// Particle
	CPU.GetParticleData()->Create(1000000);
	CPU.GetParticlePhysics()->gy = -0.5f;
	m_pEmitter = CPU.CreateParticleEmitter();
	m_pEmitter->density = 3000.0f;
	m_pEmitter->colorMin = cpu::ToColor(255, 0, 0);
	m_pEmitter->colorMax = cpu::ToColor(255, 128, 0);

	// Camera
	//CPU.GetCamera()->perspective = false;
	//CPU.GetCamera()->UpdateProjection();
	CPU.GetCamera()->transform.pos.z = -5.0f;
}

void App::OnUpdate()
{
	// YOUR CODE HERE

	float dt = CPU.DeltaTime();
	float time = CPU.TotalTime();

	// Move sprite
	m_pSprite->y = 60 + cpu::RoundToInt(sinf(time)*20.0f);

	// Turn ball
	m_pBall->transform.AddYPR(dt);

	// Move rock
	m_pRock->transform.OrbitAroundAxis(m_pBall->transform.pos, CPU_UP, 3.0f, time*2.0f);
	m_pEmitter->pos = m_pRock->transform.pos;
	m_pEmitter->dir = m_pRock->transform.dir;
	m_pEmitter->dir.x = -m_pEmitter->dir.x; 
	m_pEmitter->dir.y = -m_pEmitter->dir.y; 
	m_pEmitter->dir.z = -m_pEmitter->dir.z; 

	// Turn camera
	CPU.GetCamera()->transform.AddYPR(0.0f, 0.0f, dt*0.1f);

	// Move ship
	if ( CPU.Input()->IsKey(VK_UP) )
	{
		CPU.GetCamera()->transform.Move(CPU.DeltaTime()*1.0f);
	}
	if ( CPU.Input()->IsKey(VK_DOWN) )
	{
		CPU.GetCamera()->transform.Move(-CPU.DeltaTime()*1.0f);
	}

	// Move missiles
	for ( auto it=m_missiles.begin() ; it!=m_missiles.end() ; ++it )
	{
		cpu_entity* pMissile = *it;
		pMissile->transform.Move(dt*m_missileSpeed);
		if ( pMissile->lifetime>10.0f )
			CPU.Release(pMissile);
	}

	// Fire
	if ( CPU.Input()->IsKeyDown(VK_LBUTTON) || CPU.Input()->IsKey(VK_RBUTTON) )
		APP.SpawnMissileWithMouse();

	// Purge missiles
	for ( auto it=m_missiles.begin() ; it!=m_missiles.end() ; )
	{
		if ( (*it)->dead )
			it = m_missiles.erase(it);
		else
			++it;
	}

	// Quit
	if ( CPU.Input()->IsKeyDown(VK_ESCAPE) )
		CPU.Quit();
}

void App::OnExit()
{
	// YOUR CODE HERE

	CPU_DELPTR(m_pShip);
	m_missiles.clear();
}

void App::OnRender(int pass)
{
	// YOUR CODE HERE

	switch ( pass )
	{
		case CPU_PASS_PARTICLE_BEGIN:
		{
			// Blur particles
			CPU.SetRT(m_rts[0]);
			CPU.ClearColor();
			break;
		}
		case CPU_PASS_PARTICLE_END:
		{
			// Blur particles
			CPU.Blur(10);
			CPU.SetMainRT();
			CPU.AlphaBlend(m_rts[0]);
			break;
		}
		case CPU_PASS_UI_END:
		{
			// Debug
			cpu_stats& stats = *CPU.GetStats();
			std::string info = CPU_STR(stats.fps) + " fps, ";
			info += CPU_STR(stats.drawnTriangleCount) + " triangles, ";
			info += CPU_STR(stats.clipEntityCount) + " clipped entities\n";
			info += CPU_STR(m_missiles.size()) + " missiles, ";
			info += CPU_STR(CPU.GetParticleData()->alive) + " particles, ";
			info += CPU_STR(stats.threadCount) + " threads, ";
			info += CPU_STR(stats.tileCount) + " tiles";

			// Ray cast
			cpu_ray ray;
			CPU.GetCursorRay(ray);
			cpu_hit hit;
			cpu_entity* pEntity = CPU.HitEntity(hit, ray);
			if ( pEntity )
			{
				info += "\nHIT: ";
				info += CPU_STR(pEntity->index).c_str();
			}

			CPU.DrawText(&m_font, info.c_str(), (int)CPU.GetMainRT()->widthHalf, 10, CPU_TEXT_CENTER);
			break;
		}
	}
}

void App::MissileShader(cpu_ps_io& io)
{
	// garder seulement le rouge du pixel éclairé
	io.color.x = io.p.color.x;
}

void App::RockShader(cpu_ps_io& io)
{
	float time = CPU.TotalTime();
	float scale = ((sinf(time*3.0f)*0.5f)+0.5f) * 0.5f + 0.5f; 
	io.color.x = io.p.color.x * scale;
	io.color.y = io.p.color.y * scale;
	io.color.z = io.p.color.z;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Ship::Ship()
{
	m_pEntity = nullptr;
	m_pFSM = nullptr;
}

Ship::~Ship()
{
}

void Ship::Create(cpu_mesh* pMesh, cpu_material* pMaterial)
{
	m_pEntity = CPU.CreateEntity();
	m_pEntity->pMesh = pMesh;
	m_pEntity->pMaterial = pMaterial;
	m_pEntity->transform.pos.z = 5.0f;
	m_pEntity->transform.pos.y = -3.0f;

	m_pFSM = CPU.CreateFSM(this);
	m_pFSM->SetGlobal<StateGlobal>();
	m_pFSM->Add<StateIdle>();
	m_pFSM->Add<StateBlink>();
}

void Ship::Destroy()
{
	m_pFSM = CPU.Release(m_pFSM);
	m_pEntity = CPU.Release(m_pEntity);
}

void Ship::Update()
{
	float dt = CPU.DeltaTime();

	// Turn ship
	m_pEntity->transform.AddYPR(dt, dt, dt);

	// Move ship
	m_pEntity->transform.pos.z += dt * 1.0f;

	// Fire
	if ( CPU.Input()->IsKey(VK_SPACE) )
		APP.SpawnMissile();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void StateGlobal::OnEnter(Ship& cur, int from)
{
}

void StateGlobal::OnExecute(Ship& cur)
{
	cur.Update();
}

void StateGlobal::OnExit(Ship& cur, int to)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void StateIdle::OnEnter(Ship& cur, int from)
{
}

void StateIdle::OnExecute(Ship& cur)
{
	// Blink every 3 seconds
	if ( cur.GetFSM()->totalTime>3.0f )
	{
		cur.GetFSM()->ToState(CPU_ID(StateBlink));
		return;
	}
}

void StateIdle::OnExit(Ship& cur, int to)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void StateBlink::OnEnter(Ship& cur, int from)
{
}

void StateBlink::OnExecute(Ship& cur)
{
	float v = fmod(cur.GetFSM()->totalTime, 0.2f);
	if ( v<0.1f )
	{
		cur.GetEntity()->visible = true;
	}
	else
	{
		cur.GetEntity()->visible = false;
	}

	if ( cur.GetFSM()->totalTime>1.0f )
	{
		cur.GetFSM()->ToState(CPU_ID(StateIdle));
		return;
	}
}

void StateBlink::OnExit(Ship& cur, int to)
{
}
