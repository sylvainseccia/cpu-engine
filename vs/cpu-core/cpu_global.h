#pragma once

namespace cpu
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Initialize();
void Uninitialize();

template <typename S>
int& GetStateID() { static int id = -1; return id; }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ui32 SwapRB(ui32 color);

ui32 ToRGB(XMFLOAT3& color);
ui32 ToRGB(float r, float g, float b);
ui32 ToRGB(int r, int g, int b);

ui32 ToBGR(XMFLOAT3& color);
ui32 ToBGR(float r, float g, float b);

XMFLOAT3 ToColor(int r, int g, int b);
XMFLOAT3 ToColorFromRGB(ui32 rgb);
XMFLOAT3 ToColorFromBGR(ui32 bgr);

float Lerp(float a, float b, float s);
void Lerp(float& out, float a, float b, float t);
void Lerp(XMFLOAT2& out, const XMFLOAT2& a, const XMFLOAT2& b, float t);
void Lerp(XMFLOAT3& out, const XMFLOAT3& a, const XMFLOAT3& b, float t);
void Lerp(XMFLOAT4& out, const XMFLOAT4& a, const XMFLOAT4& b, float t);
ui32 LerpColor(ui32 c0, ui32 c1, float t);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float Clamp(float v);
float Clamp(float v, float min, float max);
int Clamp(int v, int min, int max);
int FloorToInt(float v);
int CeilToInt(float v);
int RoundToInt(float v);
ui32 WangHash(ui32 x);
float Rand01(ui32& seed);
float RandSigned(ui32& seed);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static inline XMFLOAT3 Sub3(const XMFLOAT3& a, const XMFLOAT3& b) { return {a.x-b.x, a.y-b.y, a.z-b.z}; }
static inline XMFLOAT3 Add3(const XMFLOAT3& a, const XMFLOAT3& b) { return {a.x+b.x, a.y+b.y, a.z+b.z}; }
static inline XMFLOAT3 Mul3(const XMFLOAT3& a, float s) { return {a.x*s, a.y*s, a.z*s}; }
static inline float Dot3(const XMFLOAT3& a, const XMFLOAT3& b) { return a.x*b.x + a.y*b.y + a.z*b.z; }
static inline XMFLOAT3 Cross3(const XMFLOAT3& a, const XMFLOAT3& b) { return { a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x }; }

bool SphereSphere(XMFLOAT3& c1, float r1, XMFLOAT3& c2, float r2);
bool RaySphere(cpu_ray& ray, XMFLOAT3& center, float radius, XMFLOAT3& outHit, float* pOutT = nullptr);
bool RayAabb(cpu_ray& ray, cpu_aabb& box, XMFLOAT3* pOutHit = nullptr, float* outT = nullptr);
bool RayAabb(cpu_ray& ray, cpu_aabb& box, float& outTEnter, float& outTExit);
bool RayObb(cpu_ray& ray, cpu_obb& box, XMFLOAT3* pOutHit = nullptr, float* pOutT = nullptr);
bool RayTriangle(cpu_ray& ray, cpu_triangle& tri, XMFLOAT3& outHit, float* pOutT = nullptr, XMFLOAT3* pOutBary = nullptr, bool cullBackFace = false);
bool AabbAabb(cpu_aabb& a, cpu_aabb& b);
bool AabbAabbInclusive(cpu_aabb& a, cpu_aabb& b);
bool ObbObb(cpu_obb& a, cpu_obb& b);

XMFLOAT3 SphericalPoint(float r, float theta, float phi);
RECT ComputeAspectFitRect(int contentW, int contentH, int winW, int winH);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

byte* LoadFile(const char* path, int& size);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}