#include "pch.h"

cpu_sphere::cpu_sphere()
{
	Zero();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

cpu_sphere& cpu_sphere::operator=(const cpu_aabb& aabb)
{
	float sx = (aabb.max.x-aabb.min.x)*0.5f;
	float sy = (aabb.max.y-aabb.min.y)*0.5f;
	float sz = (aabb.max.z-aabb.min.z)*0.5f;

	center.x = aabb.min.x + sx;
	center.y = aabb.min.y + sy;
	center.z = aabb.min.z + sz;

	radius = std::sqrt(sx*sx + sy*sy + sz*sz);

	return *this;
}

cpu_sphere& cpu_sphere::operator=(const cpu_obb& obb)
{
	XMVECTOR c = XMVectorZero();
	for ( int i=0 ; i<8 ; ++i )
		c = XMVectorAdd(c, XMLoadFloat3(&obb.pts[i]));
	c = XMVectorScale(c, 1.0f / 8.0f);
	XMStoreFloat3(&center, c);

	float r2 = 0.0f;
	for ( int i=0 ; i<8 ; ++i )
	{
		XMVECTOR p = XMLoadFloat3(&obb.pts[i]);
		XMVECTOR d = XMVectorSubtract(p, c);
		float dist2 = XMVectorGetX(XMVector3LengthSq(d));
		if ( dist2>r2 )
			r2 = dist2;
	}
	radius = std::sqrt(r2);

	return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void cpu_sphere::Zero()
{
	center = { 0.0f, 0.0f, 0.0f };
	radius = 0.0f;
}

void XM_CALLCONV cpu_sphere::Transform(FXMMATRIX m)
{
	XMVECTOR c = XMLoadFloat3(&center);
	c = XMVector3TransformCoord(c, m);
	XMStoreFloat3(&center, c);

	// Extract scale from linear part of M and use max component
	// (robuste pour rotation + scale, et conservatif si non-uniform)
	XMVECTOR baseX = XMVectorSet(m.r[0].m128_f32[0], m.r[0].m128_f32[1], m.r[0].m128_f32[2], 0.f);
	XMVECTOR baseY = XMVectorSet(m.r[1].m128_f32[0], m.r[1].m128_f32[1], m.r[1].m128_f32[2], 0.f);
	XMVECTOR baseZ = XMVectorSet(m.r[2].m128_f32[0], m.r[2].m128_f32[1], m.r[2].m128_f32[2], 0.f);

	float sx = XMVectorGetX(XMVector3Length(baseX));
	float sy = XMVectorGetX(XMVector3Length(baseY));
	float sz = XMVectorGetX(XMVector3Length(baseZ));

	float smax = sx>sy ? (sx>sz ? sx : sz) : (sy>sz ? sy : sz);
	radius *= smax;
}
