#include "pch.h"

cpu_sphere::cpu_sphere()
{
	Zero();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

cpu_sphere& cpu_sphere::operator=(const cpu_aabb& aabb)
{
	float sx = (aabb.max.x-aabb.min.x)*0.5f;
	float sy = (aabb.max.y-aabb.min.y)*0.5f;
	float sz = (aabb.max.z-aabb.min.z)*0.5f;

	center.x = aabb.min.x + sx;
	center.y = aabb.min.y + sy;
	center.z = aabb.min.z + sz;

	radius = sqrtf(sx*sx + sy*sy + sz*sz);

	return *this;
}

cpu_sphere& cpu_sphere::operator=(const cpu_obb& obb)
{
	center = obb.center;
	radius = sqrtf(obb.half.x*obb.half.x + obb.half.y*obb.half.y + obb.half.z*obb.half.z);
	return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void cpu_sphere::Zero()
{
	center = { 0.0f, 0.0f, 0.0f };
	radius = 0.0f;
}

void XM_CALLCONV cpu_sphere::Transform(FXMMATRIX m)
{
	XMVECTOR c = XMLoadFloat3(&center);
	c = XMVector3TransformCoord(c, m);
	XMStoreFloat3(&center, c);

	// Extract scale from linear part of M and use max component
	// (robuste pour rotation + scale, et conservatif si non-uniform)
	XMVECTOR baseX = XMVectorSet(m.r[0].m128_f32[0], m.r[0].m128_f32[1], m.r[0].m128_f32[2], 0.f);
	XMVECTOR baseY = XMVectorSet(m.r[1].m128_f32[0], m.r[1].m128_f32[1], m.r[1].m128_f32[2], 0.f);
	XMVECTOR baseZ = XMVectorSet(m.r[2].m128_f32[0], m.r[2].m128_f32[1], m.r[2].m128_f32[2], 0.f);

	float sx = XMVectorGetX(XMVector3Length(baseX));
	float sy = XMVectorGetX(XMVector3Length(baseY));
	float sz = XMVectorGetX(XMVector3Length(baseZ));

	float smax = sx>sy ? (sx>sz ? sx : sz) : (sy>sz ? sy : sz);
	radius *= smax;
}
